# 数据结构

## 第1章 程序设计：综述

1．1 本书讨论的内容 1

1．2 数学知识复习 2

1．2．1 指数(exponent) 2

1．2．2 对数(logarithm) 2

1．2．3 级数(series) 3

1．2．4 模运算(modular arithmetic) 4

1．2．5 证明方法 5

1．3 递归简论 7

1．4 C++类 10

1．4．1 基本的class语法 10

1．4．2 构造函数的附加语法和访问

函数 11

1．4．3 接口与实现的分离 13

1．4．4 vector类和string类 16

1．5 C++细节 17

1．5．1 指针(pointer) 18

1．5．2 左值、右值和引用 19

1．5．3 参数传递 21

1．5．4 返回值传递 23

1．5．5 std：：swap和std：：move 25

1．5．6 五大函数：析构函数，拷贝构造

函数，移动构造函数，拷贝赋值

operator=，移动赋值operator= 26

1．5．7 C风格数组和字符串 30

1．6 模板 31

1．6．1 函数模板 31

1．6．2 类模板 32

1．6．3 Object、Comparable和一个

例子 33

1．6．4 函数对象 34

1．6．5 类模板的分离式编译 37

1．7 使用矩阵 37

1．7．1 数据成员、构造函数和基本访问

函数 38

1．7．2 operator[] 38

1．7．3 五大函数 39

小结 39

练习 39

参考文献 41

## 第2章 算法分析

2．1 数学基础 42

2．2 模型 44

2．3 要分析的问题 44

2．4 运行时间计算 47

2．4．1 一个简单的例子 47

2．4．2 一般法则 47

2．4．3 最大子序列和问题的求解 49

2．4．4 运行时间中的对数 54

2．4．5 最坏情形分析的局限性 57

小结 58

练习 58

参考文献 63

## 第3章 表、栈和队列

3．1 抽象数据类型(ADT) 64

3．2 表ADT 64

3．2．1 表的简单数组实现 65

3．2．2 简单链表 65

3．3 STL中的vector和list 67

3．3．1 迭代器 68

3．3．2 例子：对表使用erase 69

3．3．3 const_iterators 70

3．4 vector的实现 72

3．5 list的实现 76

3．6 栈ADT 86

3．6．1 栈模型 86

3．6．2 栈的实现 86

3．6．3 应用 87

3．7 队列ADT 93

3．7．1 队列模型 93

3．7．2 队列的数组实现 93

3．7．3 队列的应用 95

小结 96

练习 96

## 第4章 树

4．1 预备知识 100

4．1．1 树的实现 101

4．1．2 树的遍历及应用 102

4．2 二叉树 105

4．2．1 实现 105

4．2．2 一个例子――表达式树 105

4．3 查找树ADT――二叉查找树 108

4．3．1 contains 110

4．3．2 findMin和findMax 111

4．3．3 insert 112

4．3．4 remove 113

4．3．5 析构函数和拷贝构造函数 115

4．3．6 平均情况分析 115

4．4 AVL树 118

4．4．1 单旋转 119

4．4．2 双旋转 121

4．5 伸展树 128

4．5．1 一个简单的想法(不能直接

使用) 128

4．5．2 展开 130

4．6 树的遍历 134

4．7 B树 135

4．8 标准库中的集合与映射 140

4．8．1 集合(set) 140

4．8．2 映射(map) 141

4．8．3 set和map的实现 142

4．8．4 使用多个映射(map)的例 142

小结 147

练习 147

参考文献 153

## 第5章 散列

5．1 一般想法 155

5．2 散列函数 155

5．3 分离链接法 157

5．4 不用链表的散列表 161

5．4．1 线性探测法 161

5．4．2 平方探测法 163

5．4．3 双散列 166

5．5 再散列 167

5．6 标准库中的散列表 169

5．7 以最坏情形O(1)访问的散列表 170

5．7．1 完美散列 170

5．7．2 杜鹃散列 172

5．7．3 跳房子散列 181

5．8 通用散列 184

5．9 可扩散列 186

小结 188

练习 189

参考文献 193

## 第6章 优先队列(堆)

6．1 模型 196

6．2 一些简单的实现 197

6．3 二叉堆 197

6．3．1 结构性质 197

6．3．2 堆序性质 198

6．3．3 基本的堆操作 199

6．3．4 其他的堆操作 203

6．4 优先队列的应用 206

6．4．1 选择问题 206

6．4．2 事件模拟 207

6．5 d堆 208

6．6 左式堆 209

6．6．1 左式堆的性质 209

6．6．2 左式堆操作 210

6．7 斜堆 215

6．8 二项队列 216

6．8．1 二项队列构建 216

6．8．2 二项队列操作 217

6．8．3 二项队列的实现 219

6．9 标准库中的优先队列 224

小结 225

练习 225

参考文献 229

## 第7章 排序

7．1 预备知识 232

7．2 插入排序 233

7．2．1 算法 233

7．2．2 插入排序的STL实现 233

7．2．3 插入排序的分析 235

7．3 一些简单排序算法的下界 235

7．4 希尔排序 236

7．4．1 希尔排序的最坏情形分析 237

7．5 堆排序 239

7．5．1 堆排序的分析 241

7．6 归并排序 242

7．6．1 归并排序的分析 245

7．7 快速排序 247

7．7．1 选取枢纽元 249

7．7．2 分割策略 250

7．7．3 小数组 252

7．7．4 实际的快速排序例程 252

7．7．5 快速排序的分析 254

7．7．6 选择问题的线性期望时间

算法 256

7．8 排序算法的一般下界 258

7．8．1 决策树 258

7．9 选择问题的决策树下界 260

7．10 对手下界(adversary lower

bounds) 262

7．11 线性时间排序：桶式排序和

基数排序 265

7．12 外部排序 269

7．12．1 为什么需要一些新的算法 269

7．12．2 外部排序模型 269

7．12．3 简单算法 269

7．12．4 多路合并 270

7．12．5 多相合并 271

7．12．6 替换选择 272

小结 273

练习题 273

参考文献 278

## 第8章 不相交集类

8．1 等价关系 281

8．2 动态等价性问题 281

8．3 基本数据结构 283

8．4 灵巧求并算法 286

8．5 路径压缩 288

8．6 按秩求并和路径压缩的最坏

情形 289

8．6．1 缓慢增长的函数 289

8．6．2 通过递归分解进行的分析 290

8．6．3 一个O(M log*N)界 295

8．6．4 一个O(Mα(M， N))界 296

8．7 一个应用 297

小结 299

练习 299

参考文献 301

## 第9章 图论算法

9．1 若干定义 303

9．1．1 图的表示 304

9．2 拓扑排序 305

9．3 最短路径算法 308

9．3．1 无权最短路径 309

9．3．2 Dijkstra算法 312

9．3．3 具有负边值的图 317

9．3．4 无圈图 318

9．3．5 所有顶点对间的最短路径 320

9．3．6 最短路径的例 320

9．4 网络流问题 322

9．4．1 一个简单的最大流算法 323

9．5 最小生成树 326

9．5．1 Prim算法 327

9．5．2 Kruskal算法 329

9．6 深度优先搜索的应用 330

9．6．1 无向图 331

9．6．2 双连通性 332

9．6．3 欧拉回路 335

9．6．4 有向图 338

9．6．5 查找强分支 339

9．7 NP完全性介绍 340

9．7．1 难与易 341

9．7．2 NP类 341

9．7．3 NP完全问题 342

小结 344

练习 344

参考文献 350

## 第10章 算法设计技巧

10．1 贪婪算法 353

10．1．1 一个简单的调度问题 354

10．1．2 哈夫曼编码 355

10．1．3 近似装箱问题 359

10．2 分治算法 366

10．2．1 分治算法的运行时间 367

10．2．2 最近点问题 369

10．2．3 选择问题 371

10．2．4 一些算术问题的理论改进 374

10．3 动态规划 377

10．3．1 用表代替递归 377

10．3．2 矩阵乘法的顺序安排 379

10．3．3 最优二叉查找树 382

10．3．4 所有点对最短路径 384

10．4 随机化算法 386

10．4．1 随机数发生器 387

10．4．2 跳跃表 392

10．4．3 素性测试 393

10．5 回溯算法 396

10．5．1 收费公路重建问题 396

10．5．2 博弈 400

小结 405

练习 406

参考文献 413

## 第11章 摊还分析

11．1 一个无关的智力问题 418

11．2 二项队列 419

11．3 斜堆 423

11．4 斐波那契堆 425

11．4．1 切除左式堆中的节点 425

11．4．2 二项队列的懒惰合并 427

11．4．3 斐波那契堆操作 429

11．4．4 时间界的证明 430

11．5 伸展树 432

小结 436

练习 436

参考文献 437

## 第12章 高级数据结构及其实现

12．1 自顶向下伸展树 439

12．2 红黑树 445

12．2．1 自底向上的插入 446

12．2．2 自顶向下红黑树 447

12．2．3 自顶向下删除 452

12．3 treap树 453

12．4 后缀数组和后缀树 456

12．4．1 后缀数组 456

12．4．2 后缀树 458

12．4．3 后缀数组和后缀树的线性

时间构建 461

12．5 k-d树 471

12．6 配对堆 474

小结 479

练习 479

参考文献 483

附录A 类模板的分离式编译 486

索引 489